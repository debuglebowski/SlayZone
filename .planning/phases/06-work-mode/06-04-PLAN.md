---
phase: 06-work-mode
plan: 04
type: execute
wave: 2
depends_on: [06-01, 06-02]
files_modified:
  - src/renderer/src/components/work-mode/BrowserView.tsx
  - src/renderer/src/components/work-mode/DocumentEditor.tsx
  - src/renderer/src/components/work-mode/WorkModePage.tsx
autonomous: true

must_haves:
  truths:
    - "Browser item loads URL in webview"
    - "User can enter new URL in address bar"
    - "Document item shows markdown editor"
    - "Document changes save to database"
    - "Chat item shows ChatPanel"
  artifacts:
    - path: "src/renderer/src/components/work-mode/BrowserView.tsx"
      provides: "Webview wrapper with address bar"
      contains: "webview"
      min_lines: 40
    - path: "src/renderer/src/components/work-mode/DocumentEditor.tsx"
      provides: "Document editor wrapper using MarkdownEditor"
      min_lines: 20
    - path: "src/renderer/src/components/work-mode/WorkModePage.tsx"
      provides: "Content area renders correct component by item type"
      contains: "BrowserView"
  key_links:
    - from: "BrowserView"
      to: "webview"
      via: "src prop"
      pattern: "<webview"
    - from: "DocumentEditor"
      to: "window.api.workspaceItems.update"
      via: "onSave callback"
      pattern: "workspaceItems.update"
---

<objective>
Build content viewers for browser tabs and documents, integrate chat panel.

Purpose: Each workspace item type renders appropriate content (browser=webview, document=markdown, chat=ChatPanel).
Output: BrowserView, DocumentEditor components; WorkModePage renders content based on active item type.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/renderer/src/components/task-detail/MarkdownEditor.tsx
@src/renderer/src/components/chat/ChatPanel.tsx
@.planning/phases/06-work-mode/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BrowserView with address bar</name>
  <files>src/renderer/src/components/work-mode/BrowserView.tsx</files>
  <action>
Create component with:
- Props: url, onUrlChange
- Address bar input at top
- Webview filling remaining space
- Navigate on Enter in address bar
- Update URL when webview navigates

Key points from research:
- Use partition="persist:browser-tabs" for session sharing
- Use style={{ display: 'inline-flex' }} for proper sizing
- Listen to did-navigate event for URL updates

```typescript
import { useState, useRef, useEffect } from 'react'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { RotateCw, ArrowLeft, ArrowRight } from 'lucide-react'

interface Props {
  url: string
  onUrlChange: (url: string) => void
}

export function BrowserView({ url, onUrlChange }: Props) {
  const [inputUrl, setInputUrl] = useState(url)
  const webviewRef = useRef<Electron.WebviewTag>(null)

  // Sync input when url prop changes
  useEffect(() => {
    setInputUrl(url)
  }, [url])

  // Handle webview navigation events
  useEffect(() => {
    const webview = webviewRef.current
    if (!webview) return

    const handleNavigate = (e: Electron.DidNavigateEvent) => {
      setInputUrl(e.url)
      if (e.url !== url) onUrlChange(e.url)
    }

    webview.addEventListener('did-navigate', handleNavigate)
    webview.addEventListener('did-navigate-in-page', handleNavigate as any)
    return () => {
      webview.removeEventListener('did-navigate', handleNavigate)
      webview.removeEventListener('did-navigate-in-page', handleNavigate as any)
    }
  }, [url, onUrlChange])

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      let newUrl = inputUrl.trim()
      // Add https:// if missing protocol
      if (newUrl && !newUrl.match(/^https?:\/\//)) {
        newUrl = 'https://' + newUrl
      }
      if (newUrl && newUrl !== url) {
        onUrlChange(newUrl)
      }
    }
  }

  const handleRefresh = () => {
    webviewRef.current?.reload()
  }

  const handleBack = () => {
    webviewRef.current?.goBack()
  }

  const handleForward = () => {
    webviewRef.current?.goForward()
  }

  return (
    <div className="flex flex-col h-full">
      {/* Address bar */}
      <div className="flex items-center gap-2 p-2 border-b">
        <Button variant="ghost" size="icon" className="h-8 w-8" onClick={handleBack}>
          <ArrowLeft className="h-4 w-4" />
        </Button>
        <Button variant="ghost" size="icon" className="h-8 w-8" onClick={handleForward}>
          <ArrowRight className="h-4 w-4" />
        </Button>
        <Button variant="ghost" size="icon" className="h-8 w-8" onClick={handleRefresh}>
          <RotateCw className="h-4 w-4" />
        </Button>
        <Input
          value={inputUrl}
          onChange={(e) => setInputUrl(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 h-8 text-sm"
          placeholder="Enter URL..."
        />
      </div>
      {/* Webview */}
      <div className="flex-1 min-h-0">
        <webview
          ref={webviewRef}
          src={url}
          partition="persist:browser-tabs"
          className="w-full h-full"
          style={{ display: 'inline-flex' }}
        />
      </div>
    </div>
  )
}
```

Note: webview is a native Electron element, not imported from anywhere.
  </action>
  <verify>File exists and npm run typecheck passes</verify>
  <done>BrowserView renders webview with address bar, nav buttons, URL sync</done>
</task>

<task type="auto">
  <name>Task 2: Create DocumentEditor wrapper</name>
  <files>src/renderer/src/components/work-mode/DocumentEditor.tsx</files>
  <action>
Create component wrapping existing MarkdownEditor:
- Props: item (WorkspaceItem), onUpdate
- Manages content state locally
- Saves to database on blur/Cmd+Enter via onSave

```typescript
import { useState, useEffect } from 'react'
import type { WorkspaceItem } from '../../../../shared/types/database'
import { MarkdownEditor } from '@/components/task-detail/MarkdownEditor'

interface Props {
  item: WorkspaceItem
  onUpdate: (item: WorkspaceItem) => void
}

export function DocumentEditor({ item, onUpdate }: Props) {
  const [content, setContent] = useState(item.content ?? '')

  // Reset content when item changes
  useEffect(() => {
    setContent(item.content ?? '')
  }, [item.id, item.content])

  const handleSave = async () => {
    if (content !== item.content) {
      const updated = await window.api.workspaceItems.update({
        id: item.id,
        content
      })
      onUpdate(updated)
    }
  }

  return (
    <div className="h-full overflow-y-auto p-4">
      <MarkdownEditor
        value={content}
        onChange={setContent}
        onSave={handleSave}
        placeholder="Start writing..."
      />
    </div>
  )
}
```
  </action>
  <verify>File exists and npm run typecheck passes</verify>
  <done>DocumentEditor wraps MarkdownEditor with item persistence</done>
</task>

<task type="auto">
  <name>Task 3: Wire content rendering in WorkModePage</name>
  <files>src/renderer/src/components/work-mode/WorkModePage.tsx</files>
  <action>
Update WorkModePage to render content based on active item type.

Add imports:
```typescript
import { BrowserView } from './BrowserView'
import { DocumentEditor } from './DocumentEditor'
import { ChatPanel } from '@/components/chat/ChatPanel'
```

Find active item:
```typescript
const activeItem = items.find((i) => i.id === activeItemId) ?? null
```

Add URL change handler:
```typescript
const handleUrlChange = async (id: string, url: string) => {
  const updated = await window.api.workspaceItems.update({ id, url })
  setItems(items.map((i) => (i.id === id ? updated : i)))
}
```

Add item update handler:
```typescript
const handleItemUpdate = (updated: WorkspaceItem) => {
  setItems(items.map((i) => (i.id === updated.id ? updated : i)))
}
```

Replace main content placeholder with:
```typescript
<main className="flex-1 min-h-0">
  {!activeItem ? (
    <div className="flex items-center justify-center h-full text-muted-foreground">
      Select an item or add one to get started
    </div>
  ) : activeItem.type === 'chat' ? (
    <ChatPanel task={task} workspaceItemId={activeItem.id} />
  ) : activeItem.type === 'browser' ? (
    <BrowserView
      url={activeItem.url ?? 'https://google.com'}
      onUrlChange={(url) => handleUrlChange(activeItem.id, url)}
    />
  ) : activeItem.type === 'document' ? (
    <DocumentEditor item={activeItem} onUpdate={handleItemUpdate} />
  ) : null}
</main>
```

Ensure task is always defined when rendering content (already guarded by loading check).
  </action>
  <verify>npm run typecheck passes</verify>
  <done>WorkModePage renders chat/browser/document content based on active item type</done>
</task>

</tasks>

<verification>
- [ ] npm run typecheck passes
- [ ] BrowserView loads URL in webview
- [ ] Address bar updates on navigation
- [ ] Enter in address bar navigates
- [ ] DocumentEditor saves content on blur
- [ ] ChatPanel shows for chat items
</verification>

<success_criteria>
User can:
- View chat with Claude in chat items
- Load websites in browser items with address bar
- Edit markdown documents that persist to database
</success_criteria>

<output>
After completion, create `.planning/phases/06-work-mode/06-04-SUMMARY.md`
</output>
