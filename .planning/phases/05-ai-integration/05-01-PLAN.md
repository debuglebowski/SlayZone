---
phase: 05-ai-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/types/api.ts
  - src/shared/types/database.ts
  - src/main/db/migrations.ts
  - src/main/services/claude-spawner.ts
autonomous: true

must_haves:
  truths:
    - "Claude CLI can be spawned with task context"
    - "Streaming output parsed into typed events"
    - "Active process can be cancelled"
  artifacts:
    - path: "src/shared/types/api.ts"
      provides: "ClaudeStreamEvent, ChatMessage types"
      contains: "ClaudeStreamEvent"
    - path: "src/main/db/migrations.ts"
      provides: "chat_messages table (v3)"
      contains: "chat_messages"
    - path: "src/main/services/claude-spawner.ts"
      provides: "streamClaude, cancelClaude functions"
      exports: ["streamClaude", "cancelClaude"]
  key_links:
    - from: "src/main/services/claude-spawner.ts"
      to: "child_process.spawn"
      via: "spawn('claude', args)"
      pattern: "spawn\\('claude'"
---

<objective>
Create foundation for Claude CLI integration: types, database migration, and spawner service.

Purpose: Establish typed streaming interface and persistence layer before IPC wiring
Output: Types for stream events, chat_messages table, spawner service with spawn/cancel
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-integration/05-RESEARCH.md
@src/shared/types/api.ts
@src/shared/types/database.ts
@src/main/db/migrations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Claude streaming types</name>
  <files>src/shared/types/api.ts, src/shared/types/database.ts</files>
  <action>
Add to api.ts:

```typescript
// Claude streaming types
export interface ClaudeStreamEvent {
  type: 'system' | 'assistant' | 'result'
  subtype?: 'init' | 'success' | 'error'
  message?: {
    role: string
    content: Array<{ type: string; text?: string }>
  }
  session_id?: string
  cost?: number
}

export interface ChatMessage {
  id: string
  workspace_item_id: string
  role: 'user' | 'assistant'
  content: string
  created_at: string
}

export interface CreateChatMessageInput {
  workspaceItemId: string
  role: 'user' | 'assistant'
  content: string
}
```

Add to database.ts ChatMessage type matching DB schema (snake_case).
  </action>
  <verify>TypeScript compiles: `npm run typecheck`</verify>
  <done>ClaudeStreamEvent and ChatMessage types exported from api.ts</done>
</task>

<task type="auto">
  <name>Task 2: Add chat_messages migration (v3)</name>
  <files>src/main/db/migrations.ts</files>
  <action>
Add migration version 3 to migrations array:

```typescript
{
  version: 3,
  up: (db) => {
    db.exec(`
      CREATE TABLE chat_messages (
        id TEXT PRIMARY KEY,
        workspace_item_id TEXT NOT NULL REFERENCES workspace_items(id) ON DELETE CASCADE,
        role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
        content TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime('now'))
      );

      CREATE INDEX idx_chat_messages_workspace ON chat_messages(workspace_item_id);
    `)
  }
}
```
  </action>
  <verify>App starts without error, migration runs: check console for "Migration 3 applied"</verify>
  <done>chat_messages table exists with FK to workspace_items</done>
</task>

<task type="auto">
  <name>Task 3: Create claude-spawner service</name>
  <files>src/main/services/claude-spawner.ts</files>
  <action>
Create new file src/main/services/claude-spawner.ts:

```typescript
import { spawn, ChildProcess } from 'child_process'
import { createInterface } from 'readline'
import { BrowserWindow } from 'electron'

let activeProcess: ChildProcess | null = null

export function streamClaude(
  win: BrowserWindow,
  prompt: string,
  context?: string
): void {
  // Kill existing if any
  if (activeProcess) {
    activeProcess.kill('SIGTERM')
    activeProcess = null
  }

  // Build args
  const args = ['-p', '--output-format', 'stream-json']
  if (context) {
    args.push('--append-system-prompt', context)
  }
  args.push(prompt)

  // Spawn process
  activeProcess = spawn('claude', args, {
    stdio: ['ignore', 'pipe', 'pipe']
  })

  // Parse NDJSON from stdout
  const rl = createInterface({ input: activeProcess.stdout! })

  rl.on('line', (line) => {
    try {
      const data = JSON.parse(line)
      win.webContents.send('claude:chunk', data)
    } catch {
      // Skip non-JSON lines
    }
  })

  activeProcess.stderr?.on('data', (data) => {
    win.webContents.send('claude:error', data.toString())
  })

  activeProcess.on('close', (code) => {
    win.webContents.send('claude:done', { code })
    activeProcess = null
  })
}

export function cancelClaude(): boolean {
  if (activeProcess) {
    activeProcess.kill('SIGTERM')
    activeProcess = null
    return true
  }
  return false
}

export function getActiveProcess(): ChildProcess | null {
  return activeProcess
}
```

Note: Uses readline for NDJSON parsing (handles partial chunks). Single active process tracked for cancel support.
  </action>
  <verify>File exists with correct exports: `grep -l "export function streamClaude" src/main/services/claude-spawner.ts`</verify>
  <done>claude-spawner.ts exports streamClaude, cancelClaude, getActiveProcess</done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles without errors
- [ ] App starts and migration v3 applies
- [ ] claude-spawner.ts has all three exports
</verification>

<success_criteria>
- ClaudeStreamEvent type matches stream-json output format
- ChatMessage type ready for persistence
- chat_messages table created with proper FK
- Spawner service handles spawn, cancel, and process tracking
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-integration/05-01-SUMMARY.md`
</output>
