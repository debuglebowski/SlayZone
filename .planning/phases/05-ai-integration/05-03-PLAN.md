---
phase: 05-ai-integration
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - src/renderer/src/hooks/useClaude.ts
  - src/renderer/src/components/chat/ChatPanel.tsx
  - src/renderer/src/components/chat/ChatMessage.tsx
  - src/renderer/src/components/chat/ChatInput.tsx
  - src/renderer/src/components/chat/index.ts
autonomous: true

must_haves:
  truths:
    - "User can type and send a message"
    - "Response streams character-by-character"
    - "User can cancel ongoing response"
    - "Messages display with role distinction"
  artifacts:
    - path: "src/renderer/src/hooks/useClaude.ts"
      provides: "useReducer-based streaming hook"
      exports: ["useClaude"]
    - path: "src/renderer/src/components/chat/ChatPanel.tsx"
      provides: "Main chat container"
      contains: "ChatPanel"
    - path: "src/renderer/src/components/chat/ChatInput.tsx"
      provides: "Message input with send/cancel"
      contains: "ChatInput"
  key_links:
    - from: "src/renderer/src/hooks/useClaude.ts"
      to: "window.api.claude"
      via: "useEffect listeners"
      pattern: "window\\.api\\.claude\\.onChunk"
    - from: "src/renderer/src/components/chat/ChatPanel.tsx"
      to: "src/renderer/src/hooks/useClaude.ts"
      via: "useClaude hook"
      pattern: "useClaude\\(\\)"
---

<objective>
Build chat UI with streaming hook, message display, and input components.

Purpose: Provide user-facing chat interface that consumes streaming IPC
Output: Reusable chat components + streaming state hook
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-integration/05-RESEARCH.md
@.planning/phases/05-ai-integration/05-02-SUMMARY.md
@src/shared/types/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useClaude streaming hook</name>
  <files>src/renderer/src/hooks/useClaude.ts</files>
  <action>
Create src/renderer/src/hooks/useClaude.ts:

```typescript
import { useReducer, useCallback, useEffect } from 'react'
import type { ClaudeStreamEvent, ChatMessage } from '../../../shared/types/api'

type StreamStatus = 'idle' | 'streaming' | 'done' | 'error' | 'cancelled'

interface StreamState {
  status: StreamStatus
  content: string
  error: string | null
  messages: ChatMessage[]
}

type StreamAction =
  | { type: 'START' }
  | { type: 'CHUNK'; text: string }
  | { type: 'DONE' }
  | { type: 'ERROR'; error: string }
  | { type: 'CANCEL' }
  | { type: 'RESET' }
  | { type: 'ADD_MESSAGE'; message: ChatMessage }
  | { type: 'SET_MESSAGES'; messages: ChatMessage[] }

function streamReducer(state: StreamState, action: StreamAction): StreamState {
  switch (action.type) {
    case 'START':
      return { ...state, status: 'streaming', content: '', error: null }
    case 'CHUNK':
      return { ...state, content: state.content + action.text }
    case 'DONE':
      return { ...state, status: 'done' }
    case 'ERROR':
      return { ...state, status: 'error', error: action.error }
    case 'CANCEL':
      return { ...state, status: 'cancelled' }
    case 'RESET':
      return { ...state, status: 'idle', content: '', error: null }
    case 'ADD_MESSAGE':
      return { ...state, messages: [...state.messages, action.message] }
    case 'SET_MESSAGES':
      return { ...state, messages: action.messages }
    default:
      return state
  }
}

export function useClaude(workspaceItemId?: string) {
  const [state, dispatch] = useReducer(streamReducer, {
    status: 'idle',
    content: '',
    error: null,
    messages: []
  })

  // Load existing messages
  useEffect(() => {
    if (!workspaceItemId) return
    window.api.chatMessages.getByWorkspace(workspaceItemId).then((msgs) => {
      dispatch({ type: 'SET_MESSAGES', messages: msgs })
    })
  }, [workspaceItemId])

  // Subscribe to stream events
  useEffect(() => {
    const unsubChunk = window.api.claude.onChunk((data: ClaudeStreamEvent) => {
      if (data.type === 'assistant' && data.message?.content) {
        for (const block of data.message.content) {
          if (block.type === 'text' && block.text) {
            dispatch({ type: 'CHUNK', text: block.text })
          }
        }
      }
    })

    const unsubError = window.api.claude.onError((error) => {
      dispatch({ type: 'ERROR', error })
    })

    const unsubDone = window.api.claude.onDone(() => {
      dispatch({ type: 'DONE' })
    })

    return () => {
      unsubChunk()
      unsubError()
      unsubDone()
    }
  }, [])

  const stream = useCallback(async (prompt: string, context?: string) => {
    dispatch({ type: 'START' })
    await window.api.claude.stream(prompt, context)
  }, [])

  const cancel = useCallback(() => {
    window.api.claude.cancel()
    dispatch({ type: 'CANCEL' })
  }, [])

  const reset = useCallback(() => {
    dispatch({ type: 'RESET' })
  }, [])

  const addMessage = useCallback((message: ChatMessage) => {
    dispatch({ type: 'ADD_MESSAGE', message })
  }, [])

  return {
    ...state,
    stream,
    cancel,
    reset,
    addMessage
  }
}
```

Note: Hook manages both streaming state AND message history. workspaceItemId loads persisted messages.
  </action>
  <verify>TypeScript compiles</verify>
  <done>useClaude hook exports stream, cancel, reset, addMessage + state</done>
</task>

<task type="auto">
  <name>Task 2: Build chat components</name>
  <files>src/renderer/src/components/chat/ChatPanel.tsx, src/renderer/src/components/chat/ChatMessage.tsx, src/renderer/src/components/chat/ChatInput.tsx, src/renderer/src/components/chat/index.ts</files>
  <action>
Create src/renderer/src/components/chat/ directory with 4 files:

**ChatMessage.tsx:**
```typescript
import { cn } from '@/lib/utils'
import type { ChatMessage as ChatMessageType } from '../../../../shared/types/api'

interface Props {
  message: ChatMessageType
}

export function ChatMessage({ message }: Props) {
  const isUser = message.role === 'user'

  return (
    <div className={cn('flex', isUser ? 'justify-end' : 'justify-start')}>
      <div
        className={cn(
          'max-w-[80%] rounded-lg px-4 py-2',
          isUser ? 'bg-primary text-primary-foreground' : 'bg-muted'
        )}
      >
        <p className="text-sm whitespace-pre-wrap">{message.content}</p>
      </div>
    </div>
  )
}
```

**ChatInput.tsx:**
```typescript
import { useState, useRef, useEffect } from 'react'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { Send, Square } from 'lucide-react'

interface Props {
  onSend: (message: string) => void
  onCancel: () => void
  isStreaming: boolean
  disabled?: boolean
}

export function ChatInput({ onSend, onCancel, isStreaming, disabled }: Props) {
  const [value, setValue] = useState('')
  const textareaRef = useRef<HTMLTextAreaElement>(null)

  useEffect(() => {
    if (!isStreaming && textareaRef.current) {
      textareaRef.current.focus()
    }
  }, [isStreaming])

  const handleSubmit = () => {
    if (value.trim() && !isStreaming) {
      onSend(value.trim())
      setValue('')
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSubmit()
    }
  }

  return (
    <div className="flex gap-2 p-4 border-t">
      <Textarea
        ref={textareaRef}
        value={value}
        onChange={(e) => setValue(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder="Ask Claude..."
        disabled={disabled || isStreaming}
        className="min-h-[60px] resize-none"
        rows={2}
      />
      {isStreaming ? (
        <Button onClick={onCancel} variant="destructive" size="icon">
          <Square className="h-4 w-4" />
        </Button>
      ) : (
        <Button onClick={handleSubmit} disabled={!value.trim() || disabled} size="icon">
          <Send className="h-4 w-4" />
        </Button>
      )}
    </div>
  )
}
```

**ChatPanel.tsx:**
```typescript
import { useRef, useEffect } from 'react'
import { useClaude } from '@/hooks/useClaude'
import { ChatMessage } from './ChatMessage'
import { ChatInput } from './ChatInput'
import type { Task, ChatMessage as ChatMessageType } from '../../../../shared/types/api'

interface Props {
  task: Task
  workspaceItemId?: string
}

export function ChatPanel({ task, workspaceItemId }: Props) {
  const { messages, content, status, stream, cancel, addMessage } = useClaude(workspaceItemId)
  const scrollRef = useRef<HTMLDivElement>(null)

  // Auto-scroll on new content
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight
    }
  }, [messages, content])

  // Build task context
  const buildContext = () => {
    const lines = [
      `Current task: ${task.title}`,
      `Status: ${task.status}`,
      `Priority: P${task.priority}`
    ]
    if (task.description) lines.push(`Description: ${task.description}`)
    if (task.due_date) lines.push(`Due: ${task.due_date}`)
    return lines.join('\n')
  }

  const handleSend = async (prompt: string) => {
    // Add user message to display immediately
    const userMsg: ChatMessageType = {
      id: crypto.randomUUID(),
      workspace_item_id: workspaceItemId || '',
      role: 'user',
      content: prompt,
      created_at: new Date().toISOString()
    }
    addMessage(userMsg)

    // Persist user message if workspace exists
    if (workspaceItemId) {
      await window.api.chatMessages.create({
        workspaceItemId,
        role: 'user',
        content: prompt
      })
    }

    // Start streaming
    await stream(prompt, buildContext())
  }

  // Save assistant response when done
  useEffect(() => {
    if (status === 'done' && content && workspaceItemId) {
      const assistantMsg: ChatMessageType = {
        id: crypto.randomUUID(),
        workspace_item_id: workspaceItemId,
        role: 'assistant',
        content,
        created_at: new Date().toISOString()
      }
      addMessage(assistantMsg)
      window.api.chatMessages.create({
        workspaceItemId,
        role: 'assistant',
        content
      })
    }
  }, [status, content, workspaceItemId, addMessage])

  const isStreaming = status === 'streaming'

  return (
    <div className="flex flex-col h-full">
      <div ref={scrollRef} className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((msg) => (
          <ChatMessage key={msg.id} message={msg} />
        ))}
        {/* Show streaming content */}
        {isStreaming && content && (
          <div className="flex justify-start">
            <div className="max-w-[80%] rounded-lg px-4 py-2 bg-muted">
              <p className="text-sm whitespace-pre-wrap">{content}</p>
            </div>
          </div>
        )}
      </div>
      <ChatInput
        onSend={handleSend}
        onCancel={cancel}
        isStreaming={isStreaming}
      />
    </div>
  )
}
```

**index.ts:**
```typescript
export { ChatPanel } from './ChatPanel'
export { ChatMessage } from './ChatMessage'
export { ChatInput } from './ChatInput'
```

Note: ChatPanel manages full flow - context building, message display, persistence on stream done.
  </action>
  <verify>TypeScript compiles</verify>
  <done>Chat components ready: ChatPanel, ChatMessage, ChatInput exported from index.ts</done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles
- [ ] All 4 chat files exist in components/chat/
- [ ] useClaude hook exports all required functions
</verification>

<success_criteria>
- useClaude manages streaming state + message history
- ChatPanel shows messages and streaming content
- ChatInput handles send (Enter) and cancel
- Messages auto-scroll as content arrives
- User/assistant messages visually distinct
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-integration/05-03-SUMMARY.md`
</output>
