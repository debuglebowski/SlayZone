---
phase: 05-ai-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/main/ipc/claude.ts
  - src/main/ipc/database.ts
  - src/main/index.ts
  - src/preload/index.ts
  - src/preload/index.d.ts
  - src/shared/types/api.ts
autonomous: true

must_haves:
  truths:
    - "Renderer can start Claude stream via IPC"
    - "Chunks arrive in renderer via callback"
    - "Renderer can cancel active stream"
    - "Chat messages persist to database"
  artifacts:
    - path: "src/main/ipc/claude.ts"
      provides: "IPC handlers for claude:stream:start, claude:stream:cancel"
      exports: ["registerClaudeHandlers"]
    - path: "src/preload/index.ts"
      provides: "claude API in preload"
      contains: "claude:"
    - path: "src/shared/types/api.ts"
      provides: "chatMessages in ElectronAPI"
      contains: "chatMessages"
  key_links:
    - from: "src/preload/index.ts"
      to: "src/main/ipc/claude.ts"
      via: "ipcRenderer.invoke('claude:stream:start')"
      pattern: "claude:stream:start"
    - from: "src/main/ipc/claude.ts"
      to: "src/main/services/claude-spawner.ts"
      via: "import { streamClaude }"
      pattern: "streamClaude"
---

<objective>
Wire Claude spawner through IPC layer and extend preload with streaming callbacks.

Purpose: Bridge main process spawner to renderer with proper event forwarding
Output: Full IPC layer for streaming + chatMessages CRUD
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-ai-integration/05-RESEARCH.md
@.planning/phases/05-ai-integration/05-01-SUMMARY.md
@src/main/ipc/database.ts
@src/main/index.ts
@src/preload/index.ts
@src/shared/types/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create claude IPC handlers</name>
  <files>src/main/ipc/claude.ts</files>
  <action>
Create new file src/main/ipc/claude.ts:

```typescript
import { ipcMain, BrowserWindow } from 'electron'
import { streamClaude, cancelClaude } from '../services/claude-spawner'

export function registerClaudeHandlers(): void {
  ipcMain.handle('claude:stream:start', (event, prompt: string, context?: string) => {
    const win = BrowserWindow.fromWebContents(event.sender)
    if (win) {
      streamClaude(win, prompt, context)
    }
  })

  ipcMain.on('claude:stream:cancel', () => {
    cancelClaude()
  })
}
```

Note: Uses handle() for start (renderer awaits confirmation), on() for cancel (fire-and-forget).
  </action>
  <verify>File exists with registerClaudeHandlers export</verify>
  <done>claude.ts registers IPC handlers for stream start/cancel</done>
</task>

<task type="auto">
  <name>Task 2: Add chatMessages IPC handlers</name>
  <files>src/main/ipc/database.ts, src/shared/types/api.ts</files>
  <action>
Add to database.ts (after existing handlers):

```typescript
// Chat Messages
ipcMain.handle('db:chatMessages:getByWorkspace', (_, workspaceItemId: string) => {
  return db
    .prepare('SELECT * FROM chat_messages WHERE workspace_item_id = ? ORDER BY created_at')
    .all(workspaceItemId)
})

ipcMain.handle('db:chatMessages:create', (_, data: CreateChatMessageInput) => {
  const id = crypto.randomUUID()
  db.prepare(`
    INSERT INTO chat_messages (id, workspace_item_id, role, content)
    VALUES (?, ?, ?, ?)
  `).run(id, data.workspaceItemId, data.role, data.content)
  return db.prepare('SELECT * FROM chat_messages WHERE id = ?').get(id)
})

ipcMain.handle('db:chatMessages:delete', (_, id: string) => {
  const result = db.prepare('DELETE FROM chat_messages WHERE id = ?').run(id)
  return result.changes > 0
})
```

Import CreateChatMessageInput from api.ts.

Update ElectronAPI in api.ts to add chatMessages namespace:

```typescript
chatMessages: {
  getByWorkspace: (workspaceItemId: string) => Promise<ChatMessage[]>
  create: (data: CreateChatMessageInput) => Promise<ChatMessage>
  delete: (id: string) => Promise<boolean>
}
```
  </action>
  <verify>TypeScript compiles</verify>
  <done>chatMessages CRUD available via IPC</done>
</task>

<task type="auto">
  <name>Task 3: Extend preload + register handlers in main</name>
  <files>src/preload/index.ts, src/preload/index.d.ts, src/main/index.ts, src/shared/types/api.ts</files>
  <action>
Update preload/index.ts - add claude and chatMessages to api object:

```typescript
claude: {
  stream: (prompt: string, context?: string) => {
    return ipcRenderer.invoke('claude:stream:start', prompt, context)
  },
  cancel: () => {
    ipcRenderer.send('claude:stream:cancel')
  },
  onChunk: (callback: (data: ClaudeStreamEvent) => void) => {
    const handler = (_event: unknown, data: ClaudeStreamEvent) => callback(data)
    ipcRenderer.on('claude:chunk', handler)
    return () => ipcRenderer.removeListener('claude:chunk', handler)
  },
  onError: (callback: (error: string) => void) => {
    const handler = (_event: unknown, error: string) => callback(error)
    ipcRenderer.on('claude:error', handler)
    return () => ipcRenderer.removeListener('claude:error', handler)
  },
  onDone: (callback: (result: { code: number }) => void) => {
    const handler = (_event: unknown, result: { code: number }) => callback(result)
    ipcRenderer.on('claude:done', handler)
    return () => ipcRenderer.removeListener('claude:done', handler)
  }
},
chatMessages: {
  getByWorkspace: (workspaceItemId) => ipcRenderer.invoke('db:chatMessages:getByWorkspace', workspaceItemId),
  create: (data) => ipcRenderer.invoke('db:chatMessages:create', data),
  delete: (id) => ipcRenderer.invoke('db:chatMessages:delete', id)
}
```

Import ClaudeStreamEvent type at top.

Update api.ts ElectronAPI interface to add claude namespace:

```typescript
claude: {
  stream: (prompt: string, context?: string) => Promise<void>
  cancel: () => void
  onChunk: (callback: (data: ClaudeStreamEvent) => void) => () => void
  onError: (callback: (error: string) => void) => () => void
  onDone: (callback: (result: { code: number }) => void) => () => void
}
```

Update main/index.ts:
1. Import registerClaudeHandlers from './ipc/claude'
2. Call registerClaudeHandlers() after registerDatabaseHandlers() in app.whenReady
3. Import getActiveProcess from services/claude-spawner
4. In will-quit handler, add: `const proc = getActiveProcess(); if (proc) proc.kill('SIGTERM')`
  </action>
  <verify>App starts, no TypeScript errors</verify>
  <done>Full IPC layer wired: claude streaming + chatMessages CRUD</done>
</task>

</tasks>

<verification>
- [ ] TypeScript compiles
- [ ] App starts without errors
- [ ] window.api.claude exists in devtools console
- [ ] window.api.chatMessages exists in devtools console
</verification>

<success_criteria>
- Claude stream can be started via window.api.claude.stream()
- Chunks forwarded to renderer via onChunk callback
- Active stream cancellable via window.api.claude.cancel()
- Chat messages persist via chatMessages API
- Process cleanup on app quit
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-integration/05-02-SUMMARY.md`
</output>
